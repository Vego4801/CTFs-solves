#include <iostream>
#include <string>

using namespace std;


// Found inside the "check_licence" function
uint8_t base_key[32] = {
                        0x06,0xcb,0xe0,0x8f,0xeb,0x28,0x47,0x7a,
                        0x44,0x71,0x97,0x02,0x5b,0x7e,0x3a,0x7d,
                        0xf6,0xd4,0xcd,0xa2,0xc2,0x19,0xcc,0xeb,
                        0x92,0xf1,0x83,0x7d,0xc3,0xb9,0x1b,0x1d
                    };


// This matrix was re-created with a generated function (see the below "main") from ".init_array"
// function at the beginning of the program.
// The function was debugged with those commands (defined below) in GDB
uint8_t matrix_bytes[256] = {
                0x7a,0xb6,0x32,0x11,0x3a,0x9d,0xf5,0xda,
                0x0a,0x66,0xf1,0xd7,0xba,0x02,0x19,0x90,
                0x42,0xa2,0x70,0x04,0xdd,0x1b,0x57,0x82,
                0x4a,0x65,0x8d,0x14,0x8e,0x54,0x3f,0x22,
                0x72,0x99,0x69,0xa3,0xfe,0x37,0x75,0xa8,
                0x26,0x86,0x9c,0xe6,0x93,0xe5,0x9a,0x48,
                0x52,0x1c,0x06,0x15,0x09,0x3b,0x30,0x49,
                0xc6,0xbd,0xbf,0xae,0x6c,0x27,0x6b,0x5e,
                0xd8,0x62,0x95,0x25,0xe7,0x18,0x59,0x8c,
                0x6f,0xc0,0x5a,0x12,0x61,0x10,0xfb,0x76,
                0xef,0x21,0xea,0x4c,0xe1,0x2f,0x40,0x84,
                0xf9,0xc1,0x47,0xce,0xc9,0xc4,0x13,0xfa,
                0x4f,0x73,0xe3,0x6d,0x0f,0x1e,0x97,0xc8,
                0xfc,0x7b,0xcb,0x79,0xa1,0xd0,0xa7,0x6a,
                0x05,0xa6,0x28,0x3e,0xcf,0xb2,0xa9,0xe2,
                0x3c,0x5b,0xc3,0x98,0xf4,0x08,0x35,0xc2,
                0x36,0x41,0x51,0x8b,0xb3,0xab,0xb4,0x33,
                0xee,0x43,0xeb,0x0c,0x29,0x2c,0x77,0x44,
                0x4e,0xd3,0xca,0x31,0x80,0x87,0x7c,0x68,
                0xad,0x85,0x2a,0xd1,0x53,0xb1,0x55,0x4b,
                0xe0,0x7d,0xa5,0x64,0xb0,0x16,0x67,0x8a,
                0x24,0x17,0x03,0x89,0xb5,0x56,0xd5,0x94,
                0x7f,0x00,0x01,0xb7,0xbe,0x4d,0x45,0xe4,
                0x38,0xcd,0xbc,0x7e,0xdf,0x92,0x3d,0xcc,
                0xde,0xc5,0x20,0x39,0x5f,0x74,0x9e,0xf6,
                0xd4,0xf2,0xf8,0xf3,0xed,0x07,0x63,0x2e,
                0x71,0xf0,0xe8,0x23,0x50,0x1f,0xd9,0xfd,
                0x8f,0x0d,0x88,0x91,0xaf,0x96,0xd6,0xdc,
                0xe9,0xd2,0x78,0xaa,0x34,0xb8,0x60,0x46,
                0xc7,0xff,0x2b,0x0e,0x9b,0x5d,0x1d,0xec,
                0x6e,0x9f,0xb9,0x1a,0xac,0xa0,0x2d,0x83,
                0xa4,0x81,0xbb,0x5c,0x0b,0xdb,0x58,0xf7
            };


/*
define sn
> set $al = 1
> ni

define hahaxd     (batch of commands used to quickly run the function)
> ni 12
> sn
> ni
> ni
> sn
> ni
> ni 5
> sn
> ni
> ni 6
*/



// The core was copy-pasted from IDA
bool generate_key() {
    string key = "";
    int v9 = 0;
    uint8_t xored_byte = 0;
    bool is_good = false;

    // l_key == bk ^ (x1 ^ x2 ^ ... ^ xn)

    for (int account_id = 0; account_id < 0xff; ++ account_id) {
        for (int license_id = 0; license_id < 0xff; ++ license_id) {

            key = "";
            v9 = 0;

            for (size_t key_offset = 0; key_offset < 32; ++ key_offset) {
                xored_byte = base_key[key_offset];

                for (int i = license_id-1; i >= 0; -- i) {
                    xored_byte ^= matrix_bytes[(v9 + i) & 0xff];
                }

                if (key_offset == 4 or key_offset == 9 or key_offset == 14) {
                    is_good = (xored_byte == 0x2d);

                    if (!is_good) break;
                }

                v9 += license_id + account_id;
                key.push_back(xored_byte);
            }

            if (is_good) {
                cout << "License ID: \t"  << license_id << endl;
                cout << "Account ID: \t"  << account_id << endl;
                cout << "License Key: \t" << key << endl;

                return true;
            }
        }
    }

    return false;
}



// g++ -g -o solver solver.c++
int main(int argc, char const *argv[]) {
    bool result = generate_key();

    if (result) {
        cout << "Key found!" << endl;
    } else {
        cout << "No valid key generated!" << endl;
    }

    return 0;
}